{
  "client_oidc_admin_modifyclient_name": {
    "header_en": "Name",
    "content_en": "<p>Le nom est un libellé arbitraire que vous attribuez au client OIDC que vous définissez</p>"
  },
  "client_oidc_admin_modifyclient_redirect_uri": {
    "header_en": "URI de redirection",
    "content_en": "<p>Le client doit indiquer l'URL qui accueillera l'utilisateur à son retour d'authentification par l'IdP. Cette URL doit faire partie des URL configurées auprès de l'IdP.</p><p>La valeur proposée par défaut est déduite par Aduneo Identity Federation Test. En fonction du contexte, il peut être nécessaire de modifier la partie domaine pour donner le nom avec lequel le client est visible des utilisateurs.</p><p>La valeur de ce champ doit donc être reportée dans la configuration de l'IdP.</p>"
  },
  "client_oidc_admin_modifyclient_endpoint_configuration": {
    "header_en": "Endpoint Configuration",
    "content_en": "<p>Un client OpenID Connect a besoin de connaître les points d'entrées du serveur afin d'y rediriger l'utilisateur pour authentification, puis d'y récupérer les jetons, les informations sur l'utilisateur, etc. Il s'agit d'URL publiées par l'IdP OIDC, souvent spécifiques au client.</p><p>Par exemple l'URL accueillant les utilisateurs pour authentification ressemble souvent à https://login.idp.com/&lt;un identifiant du client&gt;/oauth2/v2.0/authorize</p><p>Afin de faciliter la configuration des clients, les IdP publient souvent une URL avec l'ensemble des endpoint. La configuration se résume alors à la saisie d'une unique URL au lieu de la liste des URL des différents endpoint</p>Le client de fédération accepte les deux manières de déclaration :</p><ul><li>en choisissant Discovery URI, vous n'avez qu'à donner cette URL unique, qui ressemble souvent à https://www.idp.com/.well-known/openid-configuration</li><li>avec Local Configuration, il vous faudra donner individuellement les URL de chaque endpoint, telles qu'elles sont indiquées par l'IdP.</li></ul>"
  },
  "client_oidc_admin_modifyclient_discovery_uri": {
    "header_en": "Discovery URI",
    "content_en": "<p>L'URI de découverte (Discovery URI) donne la configuration de l'OpenID Provider (appelé dans le langage courant IdP). Elle est définie dans la spécification \"OpenID Connect Discovery 1.0 incorporating errata set 1\" (<a href=\"https://openid.net/specs/openid-connect-discovery-1_0.html \" target=\"_blank\">https://openid.net/specs/openid-connect-discovery-1_0.html</a>) qui traite de la récupération automatique de l'IdP d'un utilisateur. Si cette fonctionnalité n'est finalement pas utilisée, la récupération de la configuration de l'IdP est entrée dans les moeurs.<p><p>La plupart des IdP publient une URL retournant un fichier JSON avec la liste des différents endpoint et des informations associées. Selon les cas, ces endpoint sont communs à l'ensemble des applications authentifiées par l'IdP, sont spécifiques à une entité (IdP opérant par tenant par exemple), voire dédiés à un client (c'est-à-dire une application) particulier.</p><p>La spécification impose que l'URI de découverte soit formée de l'URL identifiant l'IdP (issuer) à laquelle est ajoutée la chaîne \"/.well-known/openid-configuration\" à la fin. On trouvera donc habituelleent des URI avec les formes suivantes</p><ul><li>https://www.idp/com/.well-known/openid-configuration quand la configuration est globale</li><li>https://&lt;tenant&gt;.idp/com/.well-known/openid-configuration pour des IdP en tenant</li><li>https://www.idp/com/&lt;client&gt;.well-known/openid-configuration lorsque la configuration est spécifique à une application ou à un tenant</li></ul>"
  },
  "client_oidc_admin_modifyclient_issuer": {
    "header_en": "Issuer",
    "content_en": "<p>L'émetteur (issuer) est l'entité qui authentifie l'utilisateur et génère les jetons. En langage commun, c'est donc l'OpenID Provider (OP ou IdP). On notera pour être plus précis qu'un même serveur peut héberger plusieurs émetteurs, par exemple s'il gère des tenants différents.</p><p>La spécification précise qu'un émetteur est donné sous la forme d'une URL en https, avec un domaine, et éventuellement un port et un chemin (mais pas de query string). Attention cette écriture est sensible à la casse.</p><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options</p><p>Voici quelques exemples d'émetteurs :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/v2.0</li><li>https://societe.okta.com</li></ul>"
  },
  "client_oidc_admin_modifyclient_authorization_endpoint": {
    "header_en": "Authorization Endpoint",
    "content_en": "<p>L'endpoint d'autorisation (authorization endpoint) est l'URL de l'IdP vers laquelle sont redirigés les utilisateurs pour y être authentifiés. C'est donc le point de départ de la cinématique OpenID Connect.</p><p>On notera qu'il n'est pas facile de traduire le terme endpoint en français. Certains utilisent point de terminaison ou point d'extrémité. Point d'entrée nous paraît un meilleur candidat, mais on préfère finalement ne pas traduire le terme qui est passé dans le langage courant informatique.<p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples d'authorization endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/authorize</li><li>https://societe.okta.com/oauth2/v1/authorize</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oidc_admin_modifyclient_token_endpoint": {
    "header_en": "Token Endpoint",
    "content_en": "<p>L'endpoint de jeton (token endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir les jetons. Il le faut lors de la cinématique initiale en présentant le code retourné par l'IdP, mais aussi par la suite s'il souhaite renouveler le jeton d'accès.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de token endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/token</li><li>https://societe.okta.com/oauth2/v1/token</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oidc_admin_modifyclient_end_session_endpoint": {
    "header_en": "Logout Endpoint",
    "content_en": "<p>L'endpoint de déconnexion (logout endpoint) est le symétrique de l'endpoint d'autorisation (authorization endpoint). Il permet de mettre fin à la session. Il represente l'URL vers laquelle l'utilisateur est redirigé avec une requête de déconnexion. La déconnexion n'est pas abordée dans la spécification principale (<a href=\"https://openid.net/specs/openid-connect-core-1_0.html \">OpenID Connect Core</a>), mais dans un document à part : <a href=\"https://openid.net/specs/openid-connect-rpinitiated-1_0.html \">OpenID Connect RP-Initiated Logout</a></p><p>La cinématique de déconnexion est similaire à celle de l'authentification : l'utilisateur est redirigé vers l'IdP qui réalise alors la déconnexion. Optionnellement, le client peut demander que l'utilisateur lui soit retourné.</p><p>Dans les informations de connexion retournées par l'URI de découverte (Discovery URI), cet endpoint est appelé endpoint de fin de session (end session endpoint) et non endpoint de déconnexion.</p><p>Attention, il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration<p>Il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration</p><p>Tout comme pour l'URL d'autorisation, la spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de logout endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/logout</li><li>https://societe.okta.com/oauth2/v1/logout</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p><p>Le mécanisme de déconnexion peut aller plus loin, afin que la déconnexion soit propagée à toutes les applications auxquelles l'utilisateur est authentifié (par le même IdP en session SSO s'entend). OpenID Connect définit pour cela deux méthodes : <a href=\"https://openid.net/specs/openid-connect-frontchannel-1_0.html \">OpenID Connect Front-Channel Logout</a> et <a href=\"https://openid.net/specs/openid-connect-backchannel-1_0.html \">OpenID Connect Back-Channel Logout</a>.</p>"
  },
  "client_oidc_admin_modifyclient_userinfo_endpoint": {
    "header_en": "Userinfo Endpoint",
    "content_en": "<p>L'endpoint d'information sur l'utilisateur (userinfo endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir des informations complémentaires sur l'utilisateur.</p><p>Il est effet préconisé de ne pas transmettre de données confidentielles dans les claims du jeton qui est parfois transporté sur internet et est parfois visible de l'utilisateur. On préfère une communication directe entre serveurs au travers d'un service web exposé par l'IdP.</p><p>La sécurisation de cette API est réalisée par OAuth 2. Le client doit donc disposer d'un jeton d'accès (access token) qu'il présente lors de sa connexion au service web. Ce jeton d'accès est récupéré lors de la cinématique OpenID Connect en même temps que le jeton d'identité (ID token).</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/userinfo</li><li>https://societe.okta.com/oauth2/v1/userinfo</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oidc_admin_modifyclient_signature_key_configuration": {
    "header_en": "Signature Key Configuration",
    "content_en": "<p>Après retour d'authentification, le client se connecte à l'endpoint de jeton pour récupérer le jeton d'identité (et un jeton d'accès). Ce jeton d'identité (ID token) doit être validé avant de considérer l'authentification comme effective. Parmi les différents tests de validation, l'un des plus importants est la vérification de signature.</p><p>Le jeton d'identité est un jeton JSON (JWT) signé par une clé privée de l'IdP (ce qui en fait techniquement un JWS). Pour vérifier la signature, le client doit disposer de la clé publique de l'IdP correspondant à la clé de signature.</p><p>Les clés étant susceptibles de changer dans le temps (leur rotation étant une bonne pratique de sécurité), les IdP les mettent à disposition au travers d'une URL (appelée JWKS URI). Le client de fédération donne toutefois la possibilité de fournir manuellement la bonne clé à des fins de test.</p><ul><li>JWKS URI : URL de récupération automatique des clés publiques, (par exemple https://societe.okta.com/oauth2/v1/keys). Lorsque la configuration des endpoint est réalisée automatiquement, l'URL est récupérée à cette occasion</li><li>Local configuration : la clé publique est fournie directement dans le formulaire</li></ul>"
  },
  "client_oidc_admin_modifyclient_jwks_uri": {
    "header_en": "JWKS URI",
    "content_en": "<p>L'URI JWKS est publiée par l'IdP pour que le client récupère en temps réel la liste des clés publiques à utiliser pour vérifier la signature du jeton d'identité (et celle des jetons d'accès s'ils sont au format Json Web Token). Afin de rendre possible une rotation des clés, l'IdP a la possibilité d'en publier plusieurs. Chaque clé est repérée par un identifiant pour que le client puisse déterminer la clé qui correspond au jeton qu'il a reçu (et qui contient la référence à l'identifiant.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/discovery/v2.0/keys</li><li>https://societe.okta.com/oauth2/v1/keys</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oidc_admin_modifyclient_signature_key": {
    "header_en": "Signature Key",
    "content_en": "<p>S'il est préférable que le client récupère en temps réel les clés de vérification du jeton par l'URI JWKS, le client de test de fédération donne la possibilité de lui fournir directement la clé à utiliser</p><p>Une clé ressemble à</p><ul><li>{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"&lt;identifiant de la clé&gt;\",\"use\":\"sig\",\"e\":\"AQAB\",\"n\":\"g53BhV2Rx5CHaa...RNozJLU0t1eNU9qplC3AbkbN3v8weG6ew\"}</li></ul><p>(il s'agit ici d'une clé RSA, mais des clés d'autres types sont permises par la norme)</p>"
  },
  "client_oidc_admin_modifyclient_client_id": {
    "header_en": "Client ID",
    "content_en": "<p>L'IdP attribue un identifiant unique à chaque application qu'il doit authentifier. Cet identifiant est appelé Client ID. C'est ce qui lui permet de savoir quelle politique de sécurité appliquer. Il sert aussi lors des différentes vérifications : authentification lors des appels d'API, validation des jetons, contrôle de l'URL de retour</p><p>Ce paramètre est évidemment à récupérer auprès de l'IdP</p>"
  },
  "client_oidc_admin_modifyclient_client_secret": {
    "header_en": "Client Secret",
    "content_en": "<p>Lorsque le client se connecte aux endpoint de l'IdP (récupération des jetons par exemple), il est formellement authentifié par la donnée du Client ID et par une méthode d'authentification. Le client de test de fédération n'est actuellement compatible qu'avec la méthode client_secret_post, qui est un simple mot de passe.</p><p>Les autres méthodes d'authentification sera prochainement prises en charge :</p><ul><li>client_secret_basic : transmission du mot de passe en en-tête de la requête HTTP</li><li>client_secret_jwt : authentification par JWT signé en HMAC (de fait une authentification par HMAC)</li><li>private_key_jwt : authentification par JWT signé par une clé privée. La clé publique doit être communiquée à l'IdP pour qu'il puisse vérifier la signature</li></ul><p>Les jetons non signés (méthode none) ne sont pas autorisés pour des raisons évidentes de sécurité</p>"
  },
  "client_oidc_admin_modifyclient_scope": {
    "header_en": "Scope",
    "content_en": "<p>Le scope OAuth 2 permet de véhiculer le type d'autorisation demandée au serveur d'autorisation. Une application pourra par exemple demander des droits en écriture sur un objet particulier, et l'exprimera en fournissant des scopes (périmètres) associés. OpenID Connect en détourne un peu la définition pour son utilisation propre. Il sert au client de préciser la demande d'authentification.</p><p>Le client doit nécessairement demander le scope \"openid\" qui indique au serveur qu'il s'agit d'une demande d'authentification OpenID Connect et non une cinématique OAuth 2.</p><p>En ajoutant le scope offline_access, le client indique à l'IdP qu'il souhaite recevoir un jeton de rafraîchissement du jeton d'accès en même temps que les autres jetons.</p><p>D'autres valeurs sont utilisées pour demander à recevoir des informations sur l'utilisateur authentifié (appelées claims). Il s'agit de</p><ul><li>profile : ensemble d'informations par défaut (nom, nom de famille, prénom, second prénom, alias, etc.)</li><li>email : adresse de messagerie et indication que cette adresse a bien été vérifiée</li><li>address : adresse</li><li>phone : numéro de téléphone et indication que ce numéro a bien été vérifié</li></ul><p>L'utilisation de scopes pour identifier les informations à retourner est, on le voit, limitée. Le client n'a évidemment aucune garantie que l'information lui soit fournie (par exemple si l'utilisateur n'a pas donné son consentement). La plupart du temps, les informations à transmettre au client sont configurées au niveau de l'IdP, qui précise en plus la manière dont elles sont communiquées : dans le jeton d'identité, dans le jeton d'accès et/ou au travers de l'API userinfo.</p>"
  },
  "client_oidc_admin_modifyclient_response_type": {
    "header_en": "Response Type",
    "content_en": "<p>Le paramètre response type indique la cinématique souhaitée par le client : code d'autorisation, implicite, hybride. Etant donné que la cinématique implicite a été rendue obsolète, le client de test de fédération ne propose que la cinématique code.</p>"
  },
  "client_oidc_admin_modifyclient_token_endpoint_auth_method": {
    "header_en": "Auth method",
    "content_en": "<p>Les méthodes d'autorisation courantes sont :</p><p>Client Secret Basic :</p><p>Le client utilise son client_id et son client_secret pour s'authentifier auprès du serveur d'autorisation.</p><p>Ces informations d'identification sont incluses dans le header de la requête et encodées en base64 (client_id:client_secret)</p><br/><p>Client Secret Post :</p><p>Comme Client Secret Basic, mais les informations d'identification sont transmises dans le corps de la requête POST au lieu de l'en-tête.</p>"
  },
  "client_oidc_admin_modifyclient_fetch_userinfo": {
    "header_en": "Userinfo Retrieval",
    "content_en": "<p>Ce paramètre ne configure pas le protocole OIDC. Il indique uniquement au client de test de fédération que l'on souhaite tester l'endpoint userinfo après avoir récupéré les jetons.</p>"
  },
  "client_oidc_admin_modifyclient_verify_certificates": {
    "header_en": "Certificate verification",
    "content_en": "<p>Indique si le client doit vérifier la validité des certificats de l'IdP lors des connexions aux différents points d'entrées des API.</p><p>Cette vérification est l'un des points essentiels assurant la sécurité d'OpenID Connect.</p><p>Les erreurs de certificats sont la cause de nombreux dysfonctionnement, en particulier lorsque les autorités sont internes.</p>"
  },
  "client_oidc_admin_modifyclient_post_logout_redirect_uri": {
    "header_en": "Logout Endpoint",
    "content_en": "<p>L'endpoint de déconnexion (logout endpoint) est le symétrique de l'endpoint d'autorisation (authorization endpoint). Il permet de mettre fin à la session. Il represente l'URL vers laquelle l'utilisateur est redirigé avec une requête de déconnexion. La déconnexion n'est pas abordée dans la spécification principale.</p><p>La cinématique de déconnexion est similaire à celle de l'authentification : l'utilisateur est redirigé vers l'IdP qui réalise alors la déconnexion. Optionnellement, le client peut demander que l'utilisateur lui soit retourné.</p><p>Dans les informations de connexion retournées par l'URI de découverte (Discovery URI), cet endpoint est appelé endpoint de fin de session (end session endpoint) et non endpoint de déconnexion.</p><p>Attention, il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration<p>Il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration</p><p>Tout comme pour l'URL d'autorisation, la spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de logout endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/logout</li><li>https://societe.okta.com/oauth2/v1/logout</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p><p>Le mécanisme de déconnexion peut aller plus loin, afin que la déconnexion soit propagée à toutes les applications auxquelles l'utilisateur est authentifié (par le même IdP en session SSO s'entend). OpenID Connect définit pour cela deux méthodes : <a href=\"https://openid.net/specs/openid-connect-frontchannel-1_0.html \">OpenID Connect Front-Channel Logout</a> et <a href=\"https://openid.net/specs/openid-connect-backchannel-1_0.html \">OpenID Connect Back-Channel Logout</a>.</p>"
  },
  "client_oidc_login_preparerequest_token_endpoint_auth_method": {
    "header_en": "Auth method",
    "content_en": "<p>Les méthodes d'autorisation courantes sont :</p><p>Client Secret Basic :</p><p>Le client utilise son client_id et son client_secret pour s'authentifier auprès du serveur d'autorisation.</p><p>Ces informations d'identification sont incluses dans le header de la requête et encodées en base64 (client_id:client_secret)</p><br/><p>Client Secret Post :</p><p>Comme Client Secret Basic, mais les informations d'identification sont transmises dans le corps de la requête POST au lieu de l'en-tête.</p>"
  },
  "client_oidc_login_preparerequest_authorization_endpoint": {
    "header_en": "Authorization Endpoint",
    "content_en": "<p>L'endpoint d'autorisation (authorization endpoint) est l'URL de l'IdP vers laquelle sont redirigés les utilisateurs pour y être authentifiés. C'est donc le point de départ de la cinématique OpenID Connect.</p><p>On notera qu'il n'est pas facile de traduire le terme endpoint en français. Certains utilisent point de terminaison ou point d'extrémité. Point d'entrée nous paraît un meilleur candidat, mais on préfère finalement ne pas traduire le terme qui est passé dans le langage courant informatique.<p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples d'authorization endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/authorize</li><li>https://societe.okta.com/oauth2/v1/authorize</li></ul><p>On donne ici la valeur utilisée lors de la dernière tentative d'authentification, ou la valeur déduite de la configuration du client, qu'elle ait été fournie directement ou qu'elle ait été récupérée auprès de l'URL de découverte.</p><p>Vous avez le loisir de modifier cette valeur (qui ne sera pas reportée dans la configuration) et que vous retrouverez si vous refaites une nouvelle tentative d'authentification juste derrière celle-ci.</p>"
  },
  "client_oidc_login_preparerequest_token_endpoint": {
    "header_en": "Token Endpoint",
    "content_en": "<p>L'endpoint de jeton (token endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir les jetons. Il le faut lors de la cinématique initiale en présentant le code retourné par l'IdP, mais aussi par la suite s'il souhaite renouveler le jeton d'accès.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de token endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/token</li><li>https://societe.okta.com/oauth2/v1/token</li></ul><p>On donne ici la valeur utilisée lors de la dernière tentative d'authentification, ou la valeur déduite de la configuration du client, qu'elle ait été fournie directement ou qu'elle ait été récupérée auprès de l'URL de découverte.</p><p>Vous avez le loisir de modifier cette valeur (qui ne sera pas reportée dans la configuration) et que vous retrouverez si vous refaites une nouvelle tentative d'authentification juste derrière celle-ci.</p>"
  },
  "client_oidc_login_preparerequest_signature_key_configuration": {
    "header_en": "Signature Key Configuration",
    "content_en": "<p>Après retour d'authentification, le client se connecte à l'endpoint de jeton pour récupérer le jeton d'identité (et un jeton d'accès). Ce jeton d'identité (ID token) doit être validé avant de considérer l'authentification comme effective. Parmi les différents tests de validation, l'un des plus importants est la vérification de signature.</p><p>Le jeton d'identité est un jeton JSON (JWT) signé par une clé privée de l'IdP (ce qui en fait techniquement un JWS). Pour vérifier la signature, le client doit disposer de la clé publique de l'IdP correspondant à la clé de signature.</p><p>Les clés étant susceptibles de changer dans le temps (leur rotation étant une bonne pratique de sécurité), les IdP les mettent à disposition au travers d'une URL (appelée JWKS URI). Le client de fédération donne toutefois la possibilité de fournir manuellement la bonne clé à des fins de test.</p><ul><li>JWKS URI : URL de récupération automatique des clés publiques, (par exemple https://societe.okta.com/oauth2/v1/keys). Lorsque la configuration des endpoint est réalisée automatiquement, l'URL est récupérée à cette occasion</li><li>Local configuration : la clé publique est fournie directement dans le formulaire</li></ul>"
  },
  "client_oidc_login_preparerequest_jwks_uri": {
    "header_en": "JWKS URI",
    "content_en": "<p>L'URI JWKS est publiée par l'IdP pour que le client récupère en temps réel la liste des clés publiques à utiliser pour vérifier la signature du jeton d'identité (et celle des jetons d'accès s'ils sont au format Json Web Token). Afin de rendre possible une rotation des clés, l'IdP a la possibilité d'en publier plusieurs. Chaque clé est repérée par un identifiant pour que le client puisse déterminer la clé qui correspond au jeton qu'il a reçu (et qui contient la référence à l'identifiant.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/discovery/v2.0/keys</li><li>https://societe.okta.com/oauth2/v1/keys</li></ul><p>On donne ici la valeur utilisée lors de la dernière tentative d'authentification, ou la valeur déduite de la configuration du client, qu'elle ait été fournie directement ou qu'elle ait été récupérée auprès de l'URL de découverte.</p><p>Vous avez le loisir de modifier cette valeur (qui ne sera pas reportée dans la configuration) et que vous retrouverez si vous refaites une nouvelle tentative d'authentification juste derrière celle-ci.</p>"
  },
  "client_oidc_login_preparerequest_signature_key": {
    "header_en": "Signature Key",
    "content_en": "<p>S'il est préférable que le client récupère en temps réel les clés de vérification du jeton par l'URI JWKS, le client de test de fédération donne la possibilité de lui fournir directement la clé à utiliser</p><p>Une clé ressemble à</p><ul><li>{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"&lt;identifiant de la clé&gt;\",\"use\":\"sig\",\"e\":\"AQAB\",\"n\":\"g53BhV2Rx5CHaa...RNozJLU0t1eNU9qplC3AbkbN3v8weG6ew\"}</li></ul><p>(il s'agit ici d'une clé RSA, mais des clés d'autres types sont permises par la norme)</p><p>On donne ici la valeur utilisée lors de la dernière tentative d'authentification, ou la valeur fournie lors de la configuration du client.</p><p>Cette information est aussi utilisée en signature HMAC (HS256, HS384 et HS512) dans des cas particuliers.</p><p>Les spécifications OIDC indiquent que le secret de signature est <i>client_secret</i>, ce qui est habituellement interprété comme le mot de passe associé au client_id lors de la connexion à l'endpoint token pour échange du code contre un jeton. Certains IdP en ont une compréhension différente, et créent un autre secret. C'est par exemple le cas de Keycloak (testé en version 15).</p><p>Attention, le formalisme de la clé reste le même :</p><p><ul><li>{\"alg\": \"HS265\", \"kty\": \"oct\", \"use\": \"sig\", \"k\": \"IZzuJF3aDAYwjF7xUzguh8J89zLITMRNA6iCfIYzMk7Ay2ZX2IUxIT5Fkd0TqtRg9dII9eynUVjJAKc71ousrg\"}</li></ul></p><p>La valeur de l'algorithme est passée à <i>HS256</i> et la clé (paramètre <i>k</i>) est codée en base 64 URL safe.</p><p>Keycloak stocke sa clé dans sa base dans cet encodage, mais ce n'est peut-être pas le cas de tous les IdP.</p>"
  },
  "client_oidc_login_preparerequest_userinfo_endpoint": {
    "header_en": "Userinfo Endpoint",
    "content_en": "<p>L'endpoint d'information sur l'utilisateur (userinfo endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir des informations complémentaires sur l'utilisateur.</p><p>Il est effet préconisé de ne pas transmettre de données confidentielles dans les claims du jeton qui est parfois transporté sur internet et est parfois visible de l'utilisateur. On préfère une communication directe entre serveurs au travers d'un service web exposé par l'IdP.</p><p>La sécurisation de cette API est réalisée par OAuth 2. Le client doit donc disposer d'un jeton d'accès (access token) qu'il présente lors de sa connexion au service web. Ce jeton d'accès est récupéré lors de la cinématique OpenID Connect en même temps que le jeton d'identité (ID token).</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/userinfo</li><li>https://societe.okta.com/oauth2/v1/userinfo</li></ul><p>On donne ici la valeur utilisée lors de la dernière tentative d'authentification, ou la valeur déduite de la configuration du client, qu'elle ait été fournie directement ou qu'elle ait été récupérée auprès de l'URL de découverte.</p><p>Vous avez le loisir de modifier cette valeur (qui ne sera pas reportée dans la configuration) et que vous retrouverez si vous refaites une nouvelle tentative d'authentification juste derrière celle-ci.</p>"
  },
  "client_oidc_login_preparerequest_issuer": {
    "header_en": "Issuer",
    "content_en": "<p>L'émetteur (issuer) est l'entité qui authentifie l'utilisateur et génère les jetons. En langage commun, c'est donc l'OpenID Provider (OP ou IdP). On notera pour être plus précis qu'un même serveur peut héberger plusieurs émetteurs, par exemple s'il gère des tenants différents.</p><p>La spécification précise qu'un émetteur est donné sous la forme d'une URL en https, avec un domaine, et éventuellement un port et un chemin (mais pas de query string). Attention cette écriture est sensible à la casse.</p><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options</p><p>Voici quelques exemples d'émetteurs :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/v2.0</li><li>https://societe.okta.com</li></ul><p>Il ne devrait pas y avoir de raison de modifier cette valeur. Si vous changez d'IdP, il recommandé de configurer un nouveau client.</p>"
  },
  "client_oidc_login_preparerequest_scope": {
    "header_en": "Scope",
    "content_en": "<p>Le scope OAuth 2 permet de véhiculer le type d'autorisation demandée au serveur d'autorisation. Une application pourra par exemple demander des droits en écriture sur un objet particulier, et l'exprimera en fournissant des scopes (périmètres) associés. OpenID Connect en détourne un peu la définition pour son utilisation propre. Il sert au client de préciser la demande d'authentification.</p><p>Le client doit nécessairement demander le scope \"openid\" qui indique au serveur qu'il s'agit d'une demande d'authentification OpenID Connect et non une cinématique OAuth 2.</p><p>En ajoutant le scope offline_access, le client indique à l'IdP qu'il souhaite recevoir un jeton de rafraîchissement du jeton d'accès en même temps que les autres jetons.</p><p>D'autres valeurs sont utilisées pour demander à recevoir des informations sur l'utilisateur authentifié (appelées claims). Il s'agit de</p><ul><li>profile : ensemble d'informations par défaut (nom, nom de famille, prénom, second prénom, alias, etc.)</li><li>email : adresse de messagerie et indication que cette adresse a bien été vérifiée</li><li>address : adresse</li><li>phone : numéro de téléphone et indication que ce numéro a bien été vérifié</li></ul><p>L'utilisation de scopes pour identifier les informations à retourner est, on le voit, limitée. Le client n'a évidemment aucune garantie que l'information lui soit fournie (par exemple si l'utilisateur n'a pas donné son consentement). La plupart du temps, les informations à transmettre au client sont configurées au niveau de l'IdP, qui précise en plus la manière dont elles sont communiquées : dans le jeton d'identité, dans le jeton d'accès et/ou au travers de l'API userinfo.</p><p>On donne ici la valeur utilisée lors de la dernière tentative d'authentification, ou la valeur déduite de la configuration du client, qu'elle ait été fournie directement ou qu'elle ait été récupérée auprès de l'URL de découverte.</p><p>Vous avez le loisir de modifier cette valeur (qui ne sera pas reportée dans la configuration) et que vous retrouverez si vous refaites une nouvelle tentative d'authentification juste derrière celle-ci.</p><p>Vous pouvez donc changer à loisir cette valeur pour en constater les conséquences sur le comportement de l'IdP et sur les informations qu'il retourne.</p>"
  },
  "client_oidc_login_preparerequest_response_type": {
    "header_en": "Response Type",
    "content_en": "<p>Le paramètre response type indique la cinématique souhaitée par le client : code d'autorisation, implicite, hybride. Etant donné que la cinématique implicite a été rendue obsolète, le client de test de fédération ne propose que la cinématique code.</p>"
  },
  "client_oidc_login_preparerequest_client_id": {
    "header_en": "Client ID (identification de l'application par l'IdP)",
    "content_en": "<p>L'IdP attribue un identifiant unique à chaque application qu'il doit authentifier. Cet identifiant est appelé Client ID. C'est ce qui lui permet de savoir quelle politique de sécurité appliquer. Il sert aussi lors des différentes vérifications : authentification lors des appels d'API, validation des jetons, contrôle de l'URL de retour</p><p>Ce paramètre est évidemment à récupérer auprès de l'IdP</p><p>Il ne devrait pas y avoir de raison de modifier cette valeur. Si vous créez un nouveau client dans l'IdP, il recommandé de configurer un nouveau client dans Aduneo Identity Federation Test.</p>"
  },
  "client_oidc_login_preparerequest_client_secret": {
    "header_en": "Client Secret (mot de passe d'authentification de l'application)",
    "content_en": "<p>Lorsque le client se connecte aux endpoint de l'IdP (récupération des jetons par exemple), il est formellement authentifié par la donnée du Client ID et par une méthode d'authentification. Le client de test de fédération n'est actuellement compatible qu'avec la méthode client_secret_post, qui est un simple mot de passe.</p><p>Les autres méthodes d'authentification sera prochainement prises en charge :</p><ul><li>client_secret_basic : transmission du mot de passe en en-tête de la requête HTTP</li><li>client_secret_jwt : authentification par JWT signé en HMAC (de fait une authentification par HMAC)</li><li>private_key_jwt : authentification par JWT signé par une clé privée. La clé publique doit être communiquée à l'IdP pour qu'il puisse vérifier la signature</li></ul><p>Les jetons non signés (méthode none) ne sont pas autorisés pour des raisons évidentes de sécurité</p><p>Si vous ne donnez aucune valeur à ce paramètre, la valeur fournie lors de la configuration est prise. N'entrez une nouvelle valeur que si vous avez un doute sur ce que vous aviez saisi lors de la configuration.</p>"
  },
  "client_oidc_login_preparerequest_redirect_uri": {
    "header_en": "Redirect URI (URL de retour d'authentification)",
    "content_en": "<p>Le client doit indiquer l'URL qui accueillera l'utilisateur à son retour d'authentification par l'IdP. Cette URL doit faire partie des URL configurées auprès de l'IdP.</p><p>La valeur proposée par défaut est déduite par Aduneo Identity Federation Test. En fonction du contexte, il peut être nécessaire de modifier la partie domaine pour donner le nom avec lequel le client est visible des utilisateurs.</p><p>On devra s'assurer que l'URL proposée ou modifiée est correctement configurée dans l'IdP.</p>"
  },
  "client_oidc_login_preparerequest_state": {
    "header_en": "State (protection contre les authentifications non sollicitées)",
    "content_en": "<p>Un client de fédération peut communiquer un identifiant de la requête (état ou state) qu'il réalise en même temps que la requête d'authentification est envoyée à l'IdP. Ce dernier se doit alors de fournir de nouveau cette valeur lors de la réponse (lors de l'étape de communication du code). Le client a alors le moyen de vérifier que la réponse en question correspond bien à une demande qu'il a faite. Pour cela il devra évidemment avoir conservé en session l'identifiant qu'il avait généré lors de la requête.</p><p>Il est fortement recommandé de faire cette vérification afin de se prémunir contre les attaques de type CSRF où un attaquant pourrait déclencher à distance une authentification sans que l'utilisateur ne s'en aperçoive, du fait des mécanismes de SSO. Une fois une authentification acquise, l'attaquant enchaîne alors sur une attaque CSRF auprès de l'application ciblée.</p><p>Aduneo Identity Federation Test ne permet pas de modifier cette valeur qui est utilisée en interne pour le suivi des requêtes d'authentification et faire le lien avec les différents clients configurés.</p>"
  },
  "client_oidc_login_preparerequest_nonce": {
    "header_en": "Nonce (protection contre le rejeu de jeton)",
    "content_en": "<p>Le nonce ajoute une protection de sécurité parallèle à la fourniture d'un state. Il s'agit cette fois de déjouer les attaques de type rejeu.</p><p>Si un attaquant est entré en possession d'un jeton d'identité, il pourrait tenter de le présenter à l'application et usurper l'identité d'un utilisateur légitime. Ce vecteur d'attaque est l'une des raisons pour lesquelles la cinématique <i>implicit</i> a été retirée.</p><p>Mais même avec la cinématique <i>authorization code</i>, une attaque de rejeu est envisageable. On peut imaginer le cas d'un utilisateur qui vient de perdre ses accès et qui tenterait de réutiliser un ancien jeton alors que l'IdP lui refuse son authentification.</p><p>La protection contre le rejeu consiste pour le client à générer un identifiant unique lors de la demande d'authentification, qui est communiquée à l'IdP en même temps que la demande d'authentification. L'IdP intègre cet identifiant (appelé nonce - code à usage unique) dans le jeton d'identité qu'il génère et qu'il communique au client. Ce dernier vérifie alors que le nonce reçu correspond bien à celui qu'il a généré lors de la demande.</p><p>Le client devra évidemment avoir conservé le nonce en session pour le retrouver au retour d'authentification.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_display": {
    "header_en": "Display (type de page d'authentification)",
    "content_en": "<p>Le paramètre <i>display</i> a été pensé pour que les clients puissent indiquer à un IdP le type d'interface à présenter à l'utilisateur pour réaliser son authentification :</p><ul><li>page : comportement habituel où la page d'authentification remplace complètement celle de l'application dans le navigateur</li><li>popup : l'authentification est prévue pour être réalisée par une iframe s'affichant au-dessus de la page d'authentification. La taille de la page envoyée par l'IdP doit donc être adaptée à cet espace plus réduit</li><li>touch : le terminal de l'utilisateur dispose d'un écran tactile (téléphone ou tablette). L'ergonomie de l'authentification doit donc être adaptée</li><li>wap : le terminal est un ancien téléphone avec un petit écran. On peut considérer que cette option est obsolète dans l'immense majorité des cas</li><ul><p>L'effet de <i>display</i> dépend fortement des possibilités de l'IdP. La plupart d'entre-eux semble l'ignorer.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_prompt": {
    "header_en": "Prompt (interactions avec l'utilisateur)",
    "content_en": "<p>Le paramètre <i>prompt</i> indique à l'IdP les interactions qu'il souhaite qu'il ait avec l'utilisateur, en termes d'authentification et de consentement.</p><p>Plusieurs cas d'usage sont rendus possibles avec <i>prompt</i> : </p><ul><li>identification sans authentification : un portail personnalisation sa page d'accueil peut souhaiter disposer de l'identité du visiteur si elle est disponible, mais ne pas le forcer à réaliser une authentification dans le cas contraire</li><li>une application souhaite confirmer une authentification avant d réaliser une opération sensible</li><li>un utilisateur disposant de plusieurs comptes dans une application peut souhaiter basculer d'un compte à l'autre</li></ul><p>Avec <i>prompt</i> le client indique à l'IdP s'il doit afficher ou non une page d'authentification ou de sélection de consentement, essentiellement dans le cadre d'un fonctionnement en SSO (réauthentification transparente)<.p><p>Il propose les valeurs suivantes : </p><ul><li>none : l'IdP ne doit pas afficher de page d'authentification, même si le visiteur n'a pas encore été authentifié. Dans ce cas, l'IdP doit retourner une information indiquant que cet état de fait</li>login : l'IdP ne doit pas tenir compte du fait que l'utilisateur a été déjà authentifié et doit l'authentifier de nouveau</li><li>consent : l'IdP doit demander de nouveau à l'utilisateur son consentement à la transmission de ses données personnelles à l'application</li><li>select_account : l'IdP doit demander à l'utilisateur de sélectionner le compte avec lequel il souhaite être authentifié à l'application</li></ul><p>La spécification OIDC indique qu'il est possible de donner plusieurs valeurs de <i>prompt</i>, par exemple choisir un nouveau compte et forcer son authentification. Cette possibilité sera prochainement disponible avec Aduneo Identity Federation Test qui n'autorise pour le moment qu'une seule valeur.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_max_age": {
    "header_en": "Max Age (expiration de l'authentification)",
    "content_en": "<p>Le paramètre <i>max_age</i> applique une expiration de l'authentification. Si l'utilisateur a été authentifié depuis plus longtemps que le délai donné en secondes, il doit être réauthentifié.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_ui_locales": {
    "header_en": "UI Locales (langue des pages d'authentification)",
    "content_en": "<p>Le paramètre <i>ui_locales</i> indique à l'IdP les langues à utiliser dans les pages présentées au visiteur, dans l'ordre de préférence. Le formalisme pour identifier les langues suit la RFC 5646, qui peut être très complexe. La plupart du temps, on se limitera aux identifiants à 2 lettres comme en, fr ou de. Il n'est pas certain que les IdP gèrent les extensions de régionalisation comme en-us ou fr-ca.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_id_token_hint": {
    "header_en": "ID Token Hint",
    "content_en": "<p>Lorsque l'application demande une réauthentification, par exemple pour valider une transaction, il est utile de s'assurer que c'est bien le même utilisateur qui s'authentifie une nouvelle fois. Pour cela, il est possible de fournir le jeton d'identité courant avec la requête de réauthentification au travers du paramètre <i>id_token_hint</i>.</p><p>Peu d'IdP supportent ce paramètre dont l'utilité est en effet discutable.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_login_hint": {
    "header_en": "Login Hint (suggestion d'identifiant de connexion)",
    "content_en": "<p>Un mode de fonctionnement courant est de se servir d'un IdP comme hub redirigeant l'utilisateur vers son IdP en fonction de son identifiant (souvent d'après le domaine d'un identifiant de la forme adresse de messagerie). La cinématique est qu'une première page est présentée par le hub, avec saisie uniquement de l'identifiant, puis une seconde page est affichée par l'IdP final où l'utilisateur n'a plus qu'à saisir son mot de passe.</p><p>En chaînage strict, le second IdP va présenter une page classique login/password où l'utilisateur doit donc saisir une nouvelle fois son identifié déjà donné dans la première page.</p><p>Pour une cinématique plus fluide, le premier IdP passe l'identifiant de l'utilisateur au travers du paramètre <i>login_hint</i> et l'information est utilisée par le second IdP pour préremplir le login dans sa propre page, voire ne pas afficher du tout la zone de saisie correspondante.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_acr_values": {
    "header_en": "ACR Values (niveau d'authentification requis)",
    "content_en": "<p>Tous les niveaux d'authentification ne sont pas adaptés à tous les usages. La personnalisation d'une page d'accueil se contentera de suivre l'utilisateur par un cookie, alors que pour réaliser une transaction bancaire, une authentification forte est nécessaire. Avec le paramètre <i>acr_values</i>, une application a la possibilité de demander que l'authentification se fasse avec un niveau minimum donné. La configuration peut aussi être faite au niveau de l'IdP, mais le niveau requis est le même pour l'ensemble de l'application, alors que pour une expérience utilisateur optimale, il est recommandé de gradué l'authentification en fonction du contexte : l'authentification initiale sera moins contraignante que celle qui est demandée au cours de la session applicative lors de la réalisation de transactions sensibles.</p><p>Le manque de normalisation des niveaux d'authentification, malgré la RFC 6711, exige une collaboration entre l'application et l'IdP pour s'entendre sur la signification des niveaux.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "client_oidc_login_preparerequest_fetch_userinfo": {
    "header_en": "Userinfo Retrieval",
    "content_en": "<p>Ce paramètre ne configure pas le protocole OIDC. Il indique uniquement à Aduneo Identity Federation Test que l'on souhaite tester l'endpoint userinfo après avoir récupéré les jetons.</p>"
  },
  "client_oidc_login_preparerequest_verify_certificates": {
    "header_en": "Certificate verification",
    "content_en": "<p>Indique si le client doit vérifier la validité des certificats de l'IdP lors des connexions aux différents points d'entrées des API.</p><p>Cette vérification est l'un des points essentiels assurant la sécurité d'OpenID Connect.</p><p>Les erreurs de certificats sont la cause de nombreux dysfonctionnement, en particulier lorsque les autorités sont internes.</p>"
  },
  "oidc_client_callback_idp_state": {
    "header_en": "State retourné par l'IDP",
    "content_en": "<p>Le paramètre <i>state</i> est un identifiant transmis dans la requête d'authentification.</p><p>L'IdP le retourne tel quel dans l'URL de retour d'authentification, afin de vérifier que la réponse correspond bien à une demande réalisée par le client.</p><p>Si le <i>state</i> est inconnu par le client, il est probable qu'un attaquant tente de forcer une authentification, par exemple dans le but de faciliter une attaque de type CRSF.</p>"
  },
  "oidc_client_callback_idp_code": {
    "header_en": "Code d'autorisation",
    "content_en": "<p>Dans la cinématique <i>authnrization code</i>, l'IdP ne retourne pas directement des jetons, qui transiteraient alors pas le navigateur. Il transmet à la place un code à usage unique qui est utilisé par le client pour récupérer les jetons lors d'une connexion directe avec l'IdP. Le code d'autorisation est un paramètre de l'URL de retour.</p>"
  },
  "oidc_client_callback_token_endpoint": {
    "header_en": "Token Endpoint",
    "content_en": "<p>Le client va se connecter à cette API de l'IdP pour échanger le code qu'il vient de recevoir contre un jeton d'identité et un jeton d'accès.</p>"
  },
  "oidc_client_callback_jwt_id_token": {
    "header_en": "JWT ID Token",
    "content_en": "<p>L'IdP fourni le jeton d'identité sous forme d'un JWT (Json Web Token). La plupart du temps il est signé, mais il n'est pas chiffré.</p><p>Il se présente comme une structure JWS (Json Web Signature) : trois éléments séparés par des points (.) et codés en Base64 URL.</p><p>Ces trois éléments sont :</br> - un en-tête donnant des informations sur le jeton (algorithme de signature en particulier)</br> - les données véhiculées par le jeton (<i>claims</i>) dans un objet JSON</br> - la signature qui permet d'en authentifier l'origine.</p><p>Exemple de JWT :</p><p>eyJraWQiOiJUQ1hfdlRDTzNPekJXV2VfYVhCbkNaX3ItTWMyV19QWXJqbGZuU1lHcDNnIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiIwMHVwOWRqazBZYnpITTd0VTM1NiIsImVtYWlsIjoibWFyYy5waGFtQGFkdW5lby5jb20iLCJ2ZXIiOjEsImlzcyI6Imh0dHBzOi8vYWR1bmVvLm9rdGEuY29tIiwiYXVkIjoiMG9hcDlkejR3WlkxVGk1RmMzNTYiLCJpYXQiOjE2MjE4NjY4ODIsImV4cCI6MTYyMTg3MDQ4MiwianRpIjoiSUQuZHpQTGlHcXNfSlNDSURhZDJRcTZOZld6WnhZeGdhV2VlVWt4VEFHR0ttMCIsImFtciI6WyJwd2QiXSwiaWRwIjoiMDBvcDlkamlxRHdUbXRoMXozNTYiLCJub25jZSI6ImQ2MzBhMmJhLTkzOTgtNDJlMy05YWJkLTMzYmQxYzQwMzdjYyIsImF1dGhfdGltZSI6MTYyMTg2MDY4NSwiYXRfaGFzaCI6IllCSWVSVHlwX3VhSG1PWHN6aU80QncifQ.SsBw-R-Vz4SBYNjPG564m1Wbuko1o-BLRUZj_q8cqQ1PxuWkzFBaKexsFyNJR4lPtXK6-6RSXqMRTuG6j42ji7oe44XUM7GFJcnmtvvj7H36gRUFKamAxu4vQRk69owkxPsZLWVuO3tOF9V2aN9P0AU3ux3dEcDTrZdSCnlaOtE-1ab7qCDQ_EUuRuUH4En90pxXpAkgca7Db0musNCS9rXRj1h4wkjU3AkQIZSEhIoZLDzmu2gYSCfI6T1H-jhPek7Xn2FJFb66ey4wuy9V3wagmhMqiXjksDc7JxR1jNeBbv0sJRhOh5h4zH9COrqMIhSP8sjjTPU0WyJX1tNmEQ</p>"
  },
  "oidc_client_callback_id_token_header": {
    "header_en": "ID Token header",
    "content_en": "<p>L'en-tête d'un jeton d'identité contient des informations sur la signature : <br/>- l'algorithme utilisé, par défaut RS256<br/>- l'identifiant de la clé (<i>kid</i>) ayant signé le jeton, afin de la récupérer auprès de l'IdP</p>"
  },
  "oidc_client_callback_id_token_claims_set": {
    "header_en": "ID Token claims set",
    "content_en": "<p>Les informations véhiculées par un jeton d'identité sont représentées dans un objet JSON, appelé claims set. Elles sont présentes sous forme d'un couple <i>nom</i>/<i>valeur</i>.</p><p>On y retrouve trois catégories de données :<br/>- les données liées aux cinématiques OAuth 2 utilisées par OpenID Connect, utilisées pour la plupart à des fin de validation (issuer, subject, audience, expiration, etc.)<br/>- les données standard (standard claims) définies dans la norme, au nombre de 20 (nom, prénom, adresse de messagerie, etc.)<br/>- les données additionnelles (additional claims), définies par l'IdP. La norme indique qu'il est préférable que leurs noms suivent le schéma des URI pour éviter les collisions, mais que ce n'est pas une obligation sous réserve qu'il soit garantie que des collisions ne puissent se présenter</p><p>La norme laisse la possibilité de transmettre une même information déclinée en plusieurs langues, avec même des particularités régionales.</p>"
  },
  "oidc_client_callback_id_token_sub": {
    "header_en": "Identifiant de l'utilisateur (ID Token sub)",
    "content_en": "<p>La donnée <i>sub</i> représente le <i>sujet</i> et donc l'identité de l'entité authentifiée. Il doit s'agir d'un identifiant unique non réutilisable.</p><p>Il ne doit doit excéder 255 caractères et il est sensible à la casse.</p><p>Si certains IdP laissent la liberté de choisir le champ de l'annuaire sous-jacent à utiliser comme </i>sub</i>, d'autres  imposent un identifiant maîtrisés par eux. De plus, cet identifiant ne représente pas la personne (la norme parle de <i>End-User</i>, mais une de ses identités. Cela est important par exemple dans le cadre du login social où une même personne peut être authentifiée par plusieurs systèmes (par exemple Google et Facebook). Cette même personne sera donc identifiée de manière différente en fonction de la provenance de son identité.</p>"
  },
  "oidc_client_callback_nonce_verification": {
    "header_en": "Vérification de nonce",
    "content_en": "<p>Lors de la phase de préparation de l'authentification, le client associe deux identifiants à sa requête afin de sécuriser le processus:<br/>- le <i>state</i> qui vérifie que la réponse correspond à une demande effective<br/>- un <i>nonce</i></p><p>Ce <i>nonce</i> est destiné à vérifier que le jeton reçu correspond bien à une demande. Il est généré par le client et transmis à l'IdP lors de la requête d'authentification. L'IdP l'intègre tel quel dans le jeton, à charge pour le client de vérifier que c'est bien lui qui l'a généré.</p><p>Il est important qu'un attaquant ne puisse contrefaire un <i>nonce</i>. On s'abstiendra donc d'utiliser une séquence ou tout autre dispositif dont la progression est déterministe.</p><p>Aduneo Identity Federation Test utilise un UUID de type 4.</p>"
  },
  "oidc_client_callback_expiration_verification": {
    "header_en": "Vérification d'expiration",
    "content_en": "<p>Pour limiter les conséquences d'un vol de jeton et de son rejeu, les jetons d'identité expirent au terme d'un délai décidé par l'OP.</p><p>Les OP prennent souvent un délai d'une heure, mais il est préférable de prendre une valeur bien inférieure, surtout si le jeton d'identité n'est utilisé que lors de sa réception par le client afin de débuter une session applicative.</p><p>La valeur du claim <i>exp</i> est une date absolue à partir de laquelle le jeon n'est pas recevable.</p><p>Elle donnée en nombre de secondes depuis le 1er janvier 1970 UT</p><p>Lors de la phase de validation, le client doit comparer <i>exp</i> à la date (et l'heure) de la vérification, en tenant compte évidemment du fuseau horaire.</p>"
  },
  "oidc_client_callback_issuer_verification": {
    "header_en": "Vérification d'origine (issuer)",
    "content_en": "<p>Il est important de vérifier que le jeton provient bien de l'IdP interfacé avec le client et non d'un faussaire.</p><p>Lors de la configuration du client OIDC, on récupère auprès de l'IdP son identifiant (appelé issuer) afin justement d'effectuer la vérification d'origine de chaque authentification.</p><p>Le système d'origine est consigné dans le champ <i>iss</i> du jeton d'identité.</p>"
  },
  "oidc_client_callback_audience_verification": {
    "header_en": "Vérification du destinataire de l'authentification (audience)",
    "content_en": "<p>En retour d'authentification, le client OIDC doit vérifier que le jeton a bien été généré pour lui.</p><p>Un individu ayant un accès légitime à une application pourrait en effet utiliser un jeton obtenu dans ce contexte pour le présenter à une application sur laquelle il ne dispose pas des mêmes droits (ou auprès de laquelle il n'est pas autorisé).</p><p>L'IdP place dans le jeton le client ID de l'application destinataire dans le champ <i>aud</i>, à charge pour le client de vérifier qu'il s'agit bien de lui.</p>"
  },
  "oidc_client_callback_signature_key_kid": {
    "header_en": "Identifiant de la clé de signature",
    "content_en": "<p>Le jeton d'identité est signé par le serveur (OP) afin d'en certifier la provenance. Le client récupère (auprès de l'OP ou par un autre moyen) la clé permettant la vérification de signature et procède aux contrôles.</p><p>Le serveur réalise périodiquement à une rotation de ses clés, soit qu'elles aient été compromises, soit dans le cadre des bonnes pratiques de cryptographie. Se pose alors le problème de l'identification de la clé correcte à utiliser pour la vérification de signature.</p><p>A cet effet, le serveur attribue un identifiant à chaque de ses clés et l'ajoute dans le jeton. En parallèle, il publie ses différentes clés, en n'omettant pas d'indiquer leur identifiant.</p><p>On affiche ici l'identifiant de clé (kid) tel qu'il a été extrait du jeton.</p><p>Si la clé de vérification a été donnée explicitement, cet identifiant n'est pas utilisé. Mais si les clés ont été récupérées automatiquement par le client, l'identifiant sert bien évidemment à retrouver celle qui doit être utilisée.</p>"
  },
  "oidc_client_callback_jwks_endpoint": {
    "header_en": "JWKS Endpoint",
    "content_en": "<p>L'endpoint de clé est l'URL où le client peut récupérer automatiquement les clés pour la vérification de signature des jetons.</p><p>Le client va donc s'y connecter pour les obtenir.</p>"
  },
  "oidc_client_callback_keyset": {
    "header_en": "Keyset",
    "content_en": "<p>Le client s'est connecté à l'endpoint JWKS et en a récupéré la liste des clés.</p><p>On affiche ici les données brutes.</p>"
  },
  "oidc_client_callback_retrieved_keys": {
    "header_en": "Clés récupérées auprès du serveur",
    "content_en": "<p>Le client s'est connecté à l'endpoint JWKS et en a récupéré la liste des clés.</p><p>Elles sont affichées individuellement dans les lignes suivantes, indexées par leur identifiant.</p>"
  },
  "oidc_client_callback_signature_jwk": {
    "header_en": "Clé de vérification de signature",
    "content_en": "<p>Le jeton d'identité est signé par le serveur (OP) afin d'en certifier la provenance. Le client récupère (auprès de l'OP ou par un autre moyen) la clé permettant la vérification de signature et procède aux contrôles.</p><p>On affiche ici la clé qui va servir à la vérification de signature.</p><p>Elle peut avoir été donnée explicitement, comme elle peut avoir été récupérée auprès de l'endpoint JWKS. Dans ce dernier cas, le client a cherché dans la liste obtenue la clé ayant l'identifiant extrait du jeton.</p>"
  },
  "oidc_client_callback_userinfo_endpoint": {
    "header_en": "Userinfo endpoint",
    "content_en": "<p>L'endpoint d'information sur l'utilisateur (userinfo endpoint) est l'URL à laquelle se connecte le client pour obtenir des informations supplémentaires sur l'utilisateur venant de se connecter.</p><p>Le jeton d'identité contient au minimum l'identifiant de la personne, et il peut être enrichi d'informations personnelles (<i>claims</i>). Or ce jeton est dans un format qui facilite sa communication. Historiquement, il transitait même par le navigateur lorsque la cinématique (désormais obsolète) <i>implicit</i> était utilisée.</p><p>Il n'est donc pas recommandé d'y placer des informations personnelles confidentielles. La bonne pratique dicte que le jeton ne contienne que des données publiques, et que les données sensibles soient récupérées par l'application par une connexion directe à l'OP au travers de l'endpoint Userinfo.</p><p>Afin de sécuriser cette API, OpenID Connect s'appuie logiquement sur la norme OAuth et fournit un jeton d'accès en même temps que le jeton d'identité. Ce jeton d'accès a pour but principal (voire unique pour la plupart des OP) d'autoriser l'appel à Userinfo. Lorsqu'il est au format JWT, son <i>audience</i> représente l'OP.</p><p>La liste des informations transmises par l'endpoint Userinfo dépend des possibilités du serveur, de sa configuration et de la demande d'authentification.</p><p>Certains serveurs présentent exactement les mêmes informations dans le jeton d'identité et par userinfo. L'utilité de userinfo est donc limitée, et la sécurité du dispositif amoindrie.</p><p>Pour les autres serveur, l'endpoint Userinfo présente par défaut les mêmes informations que le jeton, mais il est possible de modifier ce comportement :</p><p>- directement en configurant dans le serveur les informations à intégrer dans le jeton et celles à transmettre dans userinfo</p><p>- en ajoutant le paramètre optionnel <i>claims</i> dans la requête avec un JSON listant les données à mettre dans le jeton et celles qui sont attendues dans userinfo.</p>"
  },
  "oidc_client_callback_access_token": {
    "header_en": "Jeton d'accès aux API de l'OP",
    "content_en": "<p>Le client ne récupère pas qu'un jeton d'identité (<i>ID token</i>) auprès du serveur. Il obtient en même temps un jeton d'accès lui permettant de se connecter aux différentes API proposées par le serveur.</p><p>On affiche ici ce jeton d'accès, qui va être présenté à l'endpoint Userinfo pour récupération des informations personnelles.</p><p>La norme OAuth 2 ne définit pas de format de jeton d'accès (au contraire d'OpenID Connect qui impose le format JWT pour le jeton d'identité.</p><p>Certains serveurs créent des jetons d'accès JWT, d'autres optent pour des jetons <i>opaques</i> ne contenant aucune information exploitable (pour limiter les fuites d'information). Historiquement, les assertions SAML étaient répandues.</p>"
  },
  "oidc_client_callback_at_header": {
    "header_en": "En-tête du jeton d'accès JWT",
    "content_en": "<p>Il a été déterminé que le jeton d'accès était au format JWT. On en affiche ici les en-têtes, qui contiennent classiquement :</p><p>- le type de jeton (JWT) dans le champ <i>typ</i></p><p>- l'algorithme utilisé pour sa signature (si le jeton est signé)</p><p>- l'identifiant de la clé utilisée pour signer le jeton</p>"
  },
  "oidc_client_callback_at_claims_set": {
    "header_en": "Claims contenant dans le jeton d'accès",
    "content_en": "<p>Il a été déterminé que le jeton d'accès était au format JWT. On en affiche ici le contenu.</p><p>Ce contenu dépend du serveur. Il répond cependant souvent à la norme JWT (RFC 7519).</p><p>On y retrouve donc souvent les champs suivants :</p><p>- iss : identifiant du système ayant généré le jeton</p><p>- jti : identifiant unique du jeton</p><p>- aud : identifiant du système à qui est destiné le jeton</p><p>- iat : date/heure de génération du jeton (au format Unix : nombre de secondes écoulées depuis le 1er janvier 1970 à 0 heure)</p><p>- exp : date/heure d'expiration du jeton, au format Unix</p><p>- sub : identifiant du propriétaire de la ressource accédée (la personne utilisant l'application effectuant un appel à l'API la plupart du temps)</p>"
  },
  "oidc_client_callback_user_info": {
    "header_en": "Données récupérées de l'endpoint Userinfo",
    "content_en": "<p>On affiche ici de manière brute les informations transmises par le serveur après appel à l'endpoint Userinfo.</p><p>La norme indique qu'elles doivent être représentées dans un objet JSON.</p>"
  },
  "client_oauth_admin_modifyclient_name": {
    "header_en": "Name",
    "content_en": "<p>Le nom est un libellé arbitraire que vous attribuez au client OAuth 2 que vous définissez</p>"
  },
  "client_oauth_admin_modifyclient_redirect_uri": {
    "header_en": "URI de redirection",
    "content_en": "<p>Le client doit indiquer l'URL qui accueillera l'utilisateur à son retour d'authentification par l'IdP. Cette URL doit faire partie des URL configurées auprès de l'IdP.</p><p>La valeur proposée par défaut est déduite par Aduneo Identity Federation Test. En fonction du contexte, il peut être nécessaire de modifier la partie domaine pour donner le nom avec lequel le client est visible des utilisateurs, voire de modifier le chemin.</p><p>La valeur de ce champ doit donc être reportée dans la configuration de l'IdP.</p>"
  },
  "client_oauth_admin_modifyclient_endpoint_configuration": {
    "header_en": "Endpoint Configuration",
    "content_en": "<p>Un client OAuth 2 a besoin de connaître les points d'entrées du serveur afin d'y rediriger l'utilisateur pour authentification, puis d'y récupérer les jetons, les informations sur l'utilisateur, etc. Il s'agit d'URL publiées par l'IdP, souvent spécifiques au client.</p><p>Par exemple l'URL accueillant les utilisateurs pour authentification ressemble souvent à https://login.idp.com/&lt;un identifiant du client&gt;/oauth2/v2.0/authorize</p><p>Afin de faciliter la configuration des clients, les IdP publient souvent une URL avec l'ensemble des endpoint. La configuration se résume alors à la saisie d'une unique URL au lieu de la liste des URL des différents endpoint</p>Le client de fédération accepte les deux manières de déclaration :</p><ul><li>en choisissant Discovery URI, vous n'avez qu'à donner cette URL unique, qui ressemble souvent à https://www.idp.com/.well-known/openid-configuration</li><li>avec Local Configuration, il vous faudra donner individuellement les URL de chaque endpoint, telles qu'elles sont indiquées par l'IdP.</li></ul>"
  },
  "client_oauth_admin_modifyclient_discovery_uri": {
    "header_en": "Discovery URI",
    "content_en": "<p>L'URI de découverte (Discovery URI) donne la configuration du fournisseur d'accès (appelé dans le langage courant IdP). Cet URL traite de la récupération automatique de l'IdP d'un utilisateur. Si cette fonctionnalité n'est finalement pas utilisée, la récupération de la configuration de l'IdP est entrée dans les moeurs.<p><p>La plupart des IdP publient une URL retournant un fichier JSON avec la liste des différents endpoint et des informations associées. Selon les cas, ces endpoint sont communs à l'ensemble des applications authentifiées par l'IdP, sont spécifiques à une entité (IdP opérant par tenant par exemple), voire dédiés à un client (c'est-à-dire une application) particulier.</p><p>La spécification impose que l'URI de découverte soit formée de l'URL identifiant l'IdP (issuer) à laquelle est ajoutée la chaîne \"/.well-known/openid-configuration\" à la fin. On trouvera donc habituelleent des URI avec les formes suivantes</p><ul><li>https://www.idp/com/.well-known/openid-configuration quand la configuration est globale</li><li>https://&lt;tenant&gt;.idp/com/.well-known/openid-configuration pour des IdP en tenant</li><li>https://www.idp/com/&lt;client&gt;.well-known/openid-configuration lorsque la configuration est spécifique à une application ou à un tenant</li></ul>"
  },
  "client_oauth_admin_modifyclient_issuer": {
    "header_en": "Issuer",
    "content_en": "<p>L'émetteur (issuer) est l'entité qui authentifie l'utilisateur et génère les jetons. En langage commun, c'est donc l'IdP. On notera pour être plus précis qu'un même serveur peut héberger plusieurs émetteurs, par exemple s'il gère des tenants différents.</p><p>La spécification précise qu'un émetteur est donné sous la forme d'une URL en https, avec un domaine, et éventuellement un port et un chemin (mais pas de query string). Attention cette écriture est sensible à la casse.</p><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options</p><p>Voici quelques exemples d'émetteurs :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/v2.0</li><li>https://societe.okta.com</li></ul>"
  },
  "client_oauth_admin_modifyclient_authorization_endpoint": {
    "header_en": "Authorization Endpoint",
    "content_en": "<p>L'endpoint d'autorisation (authorization endpoint) est l'URL de l'IdP vers laquelle sont redirigés les utilisateurs pour y être authentifiés. C'est donc le point de départ de la cinématique OAuth 2.</p><p>On notera qu'il n'est pas facile de traduire le terme endpoint en français. Certains utilisent point de terminaison ou point d'extrémité. Point d'entrée nous paraît un meilleur candidat, mais on préfère finalement ne pas traduire le terme qui est passé dans le langage courant informatique.<p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples d'authorization endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/authorize</li><li>https://societe.okta.com/oauth2/v1/authorize</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oauth_admin_modifyclient_token_endpoint": {
    "header_en": "Token Endpoint",
    "content_en": "<p>L'endpoint de jeton (token endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir les jetons. Il le faut lors de la cinématique initiale en présentant le code retourné par l'IdP, mais aussi par la suite s'il souhaite renouveler le jeton d'accès.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de token endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/token</li><li>https://societe.okta.com/oauth2/v1/token</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oauth_admin_modifyclient_end_session_endpoint": {
    "header_en": "Logout Endpoint",
    "content_en": "<p>L'endpoint de déconnexion (logout endpoint) est le symétrique de l'endpoint d'autorisation (authorization endpoint). Il permet de mettre fin à la session. Il represente l'URL vers laquelle l'utilisateur est redirigé avec une requête de déconnexion. La déconnexion n'est pas abordée dans la spécification principale.</p><p>La cinématique de déconnexion est similaire à celle de l'authentification : l'utilisateur est redirigé vers l'IdP qui réalise alors la déconnexion. Optionnellement, le client peut demander que l'utilisateur lui soit retourné.</p><p>Dans les informations de connexion retournées par l'URI de découverte (Discovery URI), cet endpoint est appelé endpoint de fin de session (end session endpoint) et non endpoint de déconnexion.</p><p>Attention, il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration<p>Il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration</p><p>Tout comme pour l'URL d'autorisation, la spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de logout endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/logout</li><li>https://societe.okta.com/oauth2/v1/logout</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p><p>Le mécanisme de déconnexion peut aller plus loin, afin que la déconnexion soit propagée à toutes les applications auxquelles l'utilisateur est authentifié (par le même IdP en session SSO s'entend). OpenID Connect définit pour cela deux méthodes : <a href=\"https://openid.net/specs/openid-connect-frontchannel-1_0.html \">OpenID Connect Front-Channel Logout</a> et <a href=\"https://openid.net/specs/openid-connect-backchannel-1_0.html \">OpenID Connect Back-Channel Logout</a>.</p>"
  },
  "client_oauth_admin_modifyclient_userinfo_endpoint": {
    "header_en": "Userinfo Endpoint",
    "content_en": "<p>L'endpoint d'information sur l'utilisateur (userinfo endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir des informations complémentaires sur l'utilisateur.</p><p>Il est effet préconisé de ne pas transmettre de données confidentielles dans les claims du jeton qui est parfois transporté sur internet et est parfois visible de l'utilisateur. On préfère une communication directe entre serveurs au travers d'un service web exposé par l'IdP.</p><p>La sécurisation de cette API est réalisée par OAuth 2. Le client doit donc disposer d'un jeton d'accès (access token) qu'il présente lors de sa connexion au service web. Ce jeton d'accès est récupéré lors de la cinématique OpenID Connect en même temps que le jeton d'identité (ID token).</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/userinfo</li><li>https://societe.okta.com/oauth2/v1/userinfo</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oauth_admin_modifyclient_signature_key_configuration": {
    "header_en": "Signature Key Configuration",
    "content_en": "<p>Après retour d'authentification, le client se connecte à l'endpoint de jeton pour récupérer le jeton d'identité (et un jeton d'accès). Ce jeton d'identité (ID token) doit être validé avant de considérer l'authentification comme effective. Parmi les différents tests de validation, l'un des plus importants est la vérification de signature.</p><p>Le jeton d'identité est un jeton JSON (JWT) signé par une clé privée de l'IdP (ce qui en fait techniquement un JWS). Pour vérifier la signature, le client doit disposer de la clé publique de l'IdP correspondant à la clé de signature.</p><p>Les clés étant susceptibles de changer dans le temps (leur rotation étant une bonne pratique de sécurité), les IdP les mettent à disposition au travers d'une URL (appelée JWKS URI). Le client de fédération donne toutefois la possibilité de fournir manuellement la bonne clé à des fins de test.</p><ul><li>JWKS URI : URL de récupération automatique des clés publiques, (par exemple https://societe.okta.com/oauth2/v1/keys). Lorsque la configuration des endpoint est réalisée automatiquement, l'URL est récupérée à cette occasion</li><li>Local configuration : la clé publique est fournie directement dans le formulaire</li></ul>"
  },
  "client_oauth_admin_modifyclient_jwks_uri": {
    "header_en": "JWKS URI",
    "content_en": "<p>L'URI JWKS est publiée par l'IdP pour que le client récupère en temps réel la liste des clés publiques à utiliser pour vérifier la signature du jeton d'identité (et celle des jetons d'accès s'ils sont au format Json Web Token). Afin de rendre possible une rotation des clés, l'IdP a la possibilité d'en publier plusieurs. Chaque clé est repérée par un identifiant pour que le client puisse déterminer la clé qui correspond au jeton qu'il a reçu (et qui contient la référence à l'identifiant.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/discovery/v2.0/keys</li><li>https://societe.okta.com/oauth2/v1/keys</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "client_oauth_admin_modifyclient_signature_key": {
    "header_en": "Signature Key",
    "content_en": "<p>S'il est préférable que le client récupère en temps réel les clés de vérification du jeton par l'URI JWKS, le client de test de fédération donne la possibilité de lui fournir directement la clé à utiliser</p><p>Une clé ressemble à</p><ul><li>{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"&lt;identifiant de la clé&gt;\",\"use\":\"sig\",\"e\":\"AQAB\",\"n\":\"g53BhV2Rx5CHaa...RNozJLU0t1eNU9qplC3AbkbN3v8weG6ew\"}</li></ul><p>(il s'agit ici d'une clé RSA, mais des clés d'autres types sont permises par la norme)</p>"
  },
  "client_oauth_admin_modifyclient_client_id": {
    "header_en": "Client ID",
    "content_en": "<p>L'IdP attribue un identifiant unique à chaque application qu'il doit authentifier. Cet identifiant est appelé Client ID. C'est ce qui lui permet de savoir quelle politique de sécurité appliquer. Il sert aussi lors des différentes vérifications : authentification lors des appels d'API, validation des jetons, contrôle de l'URL de retour</p><p>Ce paramètre est évidemment à récupérer auprès de l'IdP</p>"
  },
  "client_oauth_admin_modifyclient_client_secret": {
    "header_en": "Client Secret",
    "content_en": "<p>Lorsque le client se connecte aux endpoint de l'IdP (récupération des jetons par exemple), il est formellement authentifié par la donnée du Client ID et par une méthode d'authentification. Le client de test de fédération n'est actuellement compatible qu'avec la méthode client_secret_post, qui est un simple mot de passe.</p><p>Les autres méthodes d'authentification sera prochainement prises en charge :</p><ul><li>client_secret_basic : transmission du mot de passe en en-tête de la requête HTTP</li><li>client_secret_jwt : authentification par JWT signé en HMAC (de fait une authentification par HMAC)</li><li>private_key_jwt : authentification par JWT signé par une clé privée. La clé publique doit être communiquée à l'IdP pour qu'il puisse vérifier la signature</li></ul><p>Les jetons non signés (méthode none) ne sont pas autorisés pour des raisons évidentes de sécurité</p>"
  },
  "client_oauth_admin_modifyclient_scope": {
    "header_en": "Scope",
    "content_en": "<p>Le scope OAuth 2 permet de véhiculer le type d'autorisation demandée au serveur d'autorisation. Une application pourra par exemple demander des droits en écriture sur un objet particulier, et l'exprimera en fournissant des scopes (périmètres) associés.</p><p>En ajoutant le scope offline_access, le client indique à l'IdP qu'il souhaite recevoir un jeton de rafraîchissement du jeton d'accès en même temps que les autres jetons.</p>"
  },
  "client_oauth_admin_modifyclient_response_type": {
    "header_en": "Response Type",
    "content_en": "<p>Le paramètre response type indique la cinématique souhaitée par le client : code d'autorisation, implicite, hybride. Etant donné que la cinématique implicite a été rendue obsolète, le client de test de fédération ne propose que la cinématique code.</p>"
  },
  "client_oauth_admin_modifyclient_token_endpoint_auth_method": {
    "header_en": "Auth method",
    "content_en": "<p>Les méthodes d'autorisation courantes sont :</p><p>Client Secret Basic :</p><p>Le client utilise son client_id et son client_secret pour s'authentifier auprès du serveur d'autorisation.</p><p>Ces informations d'identification sont incluses dans le header de la requête et encodées en base64 (client_id:client_secret)</p><br/><p>Client Secret Post :</p><p>Comme Client Secret Basic, mais les informations d'identification sont transmises dans le corps de la requête POST au lieu de l'en-tête.</p>"
  },
  "client_oauth_admin_modifyclient_introspect_at": {
    "header_en": " Introspect access token",
    "content_en": "<p>Après obtention d'un access token on peut introspecter</p>"
  },
  "client_oauth_admin_modifyclient_rs_client_id": {
    "header_en": " Resource server client ID",
    "content_en": "<p></p>"
  },
  "client_oauth_admin_modifyclient_rs_client_secret": {
    "header_en": "Resource server client secret",
    "content_en": "<p></p>"
  },
  "client_oauth_admin_modifyclient_verify_certificates": {
    "header_en": " Verify certificates",
    "content_en": "<p>Indique si le client doit vérifier la validité des certificats de l'IdP lors des connexions aux différents points d'entrées des API.</p><p>Cette vérification est l'un des points essentiels assurant la sécurité de  OAuth 2.0.</p><p>Les erreurs de certificats sont la cause de nombreux dysfonctionnement, en particulier lorsque les autorités sont internes.</p>"
  },
  "client_oauth_admin_modifyclient_introspection_endpoint": {
    "header_en": "Introspection endpoint",
    "content_en": "<p>Il s'agit d'un URL présent chez l'IdP. Cet endpoint permet à un client de demander à l'IdP si le token en sa posession est valide. Le client délègue la vérification du token au fournisseur d'accès.</p>"
  },
  "client_oauth_admin_modifyclient_response_mode": {
    "header_en": "Response mode",
    "content_en": "<p>Le paramètre response mode permet de préciser de quelle manière le serveur d'autorisation va transmettre les informations de retour au client.</p>"
  },
  "oauth_client_preparerequest_name": {
    "header_en": "Name",
    "content_en": "<p>Le nom est un libellé arbitraire que vous attribuez au client OAuth 2 que vous définissez</p>"
  },
  "oauth_client_preparerequest_redirect_uri": {
    "header_en": "URI de redirection",
    "content_en": "<p>Le client doit indiquer l'URL qui accueillera l'utilisateur à son retour d'authentification par l'IdP. Cette URL doit faire partie des URL configurées auprès de l'IdP.</p><p>La valeur proposée par défaut est déduite par Aduneo Identity Federation Test. En fonction du contexte, il peut être nécessaire de modifier la partie domaine pour donner le nom avec lequel le client est visible des utilisateurs.</p><p>La valeur de ce champ doit donc être reportée dans la configuration de l'IdP.</p>"
  },
  "oauth_client_preparerequest_endpoint_configuration": {
    "header_en": "Endpoint Configuration",
    "content_en": "<p>Un client OAuth 2 a besoin de connaître les points d'entrées du serveur afin d'y rediriger l'utilisateur pour authentification, puis d'y récupérer les jetons, les informations sur l'utilisateur, etc. Il s'agit d'URL publiées par l'IdP, souvent spécifiques au client.</p><p>Par exemple l'URL accueillant les utilisateurs pour authentification ressemble souvent à https://login.idp.com/&lt;un identifiant du client&gt;/oauth2/v2.0/authorize</p><p>Afin de faciliter la configuration des clients, les IdP publient souvent une URL avec l'ensemble des endpoint. La configuration se résume alors à la saisie d'une unique URL au lieu de la liste des URL des différents endpoint</p>Le client de fédération accepte les deux manières de déclaration :</p><ul><li>en choisissant Discovery URI, vous n'avez qu'à donner cette URL unique, qui ressemble souvent à https://www.idp.com/.well-known/openid-configuration</li><li>avec Local Configuration, il vous faudra donner individuellement les URL de chaque endpoint, telles qu'elles sont indiquées par l'IdP.</li></ul>"
  },
  "oauth_client_preparerequest_discovery_uri": {
    "header_en": "Discovery URI",
    "content_en": "<p>L'URI de découverte (Discovery URI) donne la configuration du fournisseur d'accès (appelé dans le langage courant IdP). Cet URL traite de la récupération automatique de l'IdP d'un utilisateur. Si cette fonctionnalité n'est finalement pas utilisée, la récupération de la configuration de l'IdP est entrée dans les moeurs.<p><p>La plupart des IdP publient une URL retournant un fichier JSON avec la liste des différents endpoint et des informations associées. Selon les cas, ces endpoint sont communs à l'ensemble des applications authentifiées par l'IdP, sont spécifiques à une entité (IdP opérant par tenant par exemple), voire dédiés à un client (c'est-à-dire une application) particulier.</p><p>La spécification impose que l'URI de découverte soit formée de l'URL identifiant l'IdP (issuer) à laquelle est ajoutée la chaîne \"/.well-known/openid-configuration\" à la fin. On trouvera donc habituelleent des URI avec les formes suivantes</p><ul><li>https://www.idp/com/.well-known/openid-configuration quand la configuration est globale</li><li>https://&lt;tenant&gt;.idp/com/.well-known/openid-configuration pour des IdP en tenant</li><li>https://www.idp/com/&lt;client&gt;.well-known/openid-configuration lorsque la configuration est spécifique à une application ou à un tenant</li></ul>"
  },
  "oauth_client_preparerequest_issuer": {
    "header_en": "Issuer",
    "content_en": "<p>L'émetteur (issuer) est l'entité qui authentifie l'utilisateur et génère les jetons. En langage commun, c'est donc l'IdP. On notera pour être plus précis qu'un même serveur peut héberger plusieurs émetteurs, par exemple s'il gère des tenants différents.</p><p>La spécification précise qu'un émetteur est donné sous la forme d'une URL en https, avec un domaine, et éventuellement un port et un chemin (mais pas de query string). Attention cette écriture est sensible à la casse.</p><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options</p><p>Voici quelques exemples d'émetteurs :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/v2.0</li><li>https://societe.okta.com</li></ul>"
  },
  "oauth_client_preparerequest_authorization_endpoint": {
    "header_en": "Authorization Endpoint",
    "content_en": "<p>L'endpoint d'autorisation (authorization endpoint) est l'URL de l'IdP vers laquelle sont redirigés les utilisateurs pour y être authentifiés. C'est donc le point de départ de la cinématique OAuth 2.</p><p>On notera qu'il n'est pas facile de traduire le terme endpoint en français. Certains utilisent point de terminaison ou point d'extrémité. Point d'entrée nous paraît un meilleur candidat, mais on préfère finalement ne pas traduire le terme qui est passé dans le langage courant informatique.<p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples d'authorization endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/authorize</li><li>https://societe.okta.com/oauth2/v1/authorize</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "oauth_client_preparerequest_token_endpoint": {
    "header_en": "Token Endpoint",
    "content_en": "<p>L'endpoint de jeton (token endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir les jetons. Il le faut lors de la cinématique initiale en présentant le code retourné par l'IdP, mais aussi par la suite s'il souhaite renouveler le jeton d'accès.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de token endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/token</li><li>https://societe.okta.com/oauth2/v1/token</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "oauth_client_preparerequest_end_session_endpoint": {
    "header_en": "Logout Endpoint",
    "content_en": "<p>L'endpoint de déconnexion (logout endpoint) est le symétrique de l'endpoint d'autorisation (authorization endpoint). Il permet de mettre fin à la session. Il represente l'URL vers laquelle l'utilisateur est redirigé avec une requête de déconnexion. La déconnexion n'est pas abordée dans la spécification principale.</p><p>La cinématique de déconnexion est similaire à celle de l'authentification : l'utilisateur est redirigé vers l'IdP qui réalise alors la déconnexion. Optionnellement, le client peut demander que l'utilisateur lui soit retourné.</p><p>Dans les informations de connexion retournées par l'URI de découverte (Discovery URI), cet endpoint est appelé endpoint de fin de session (end session endpoint) et non endpoint de déconnexion.</p><p>Attention, il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration<p>Il est parfois nécessaire d'activer explicitemnet la fonctionnalité de déconnexion dans l'IdP lors de la configuration</p><p>Tout comme pour l'URL d'autorisation, la spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de logout endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/logout</li><li>https://societe.okta.com/oauth2/v1/logout</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p><p>Le mécanisme de déconnexion peut aller plus loin, afin que la déconnexion soit propagée à toutes les applications auxquelles l'utilisateur est authentifié (par le même IdP en session SSO s'entend). OpenID Connect définit pour cela deux méthodes : <a href=\"https://openid.net/specs/openid-connect-frontchannel-1_0.html \">OpenID Connect Front-Channel Logout</a> et <a href=\"https://openid.net/specs/openid-connect-backchannel-1_0.html \">OpenID Connect Back-Channel Logout</a>.</p>"
  },
  "oauth_client_preparerequest_userinfo_endpoint": {
    "header_en": "Userinfo Endpoint",
    "content_en": "<p>L'endpoint d'information sur l'utilisateur (userinfo endpoint) est l'URL de l'API de l'IdP qui est appelée directement par le client (l'application) afin d'obtenir des informations complémentaires sur l'utilisateur.</p><p>Il est effet préconisé de ne pas transmettre de données confidentielles dans les claims du jeton qui est parfois transporté sur internet et est parfois visible de l'utilisateur. On préfère une communication directe entre serveurs au travers d'un service web exposé par l'IdP.</p><p>La sécurisation de cette API est réalisée par OAuth 2. Le client doit donc disposer d'un jeton d'accès (access token) qu'il présente lors de sa connexion au service web. Ce jeton d'accès est récupéré lors de la cinématique OpenID Connect en même temps que le jeton d'identité (ID token).</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/oauth2/v2.0/userinfo</li><li>https://societe.okta.com/oauth2/v1/userinfo</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "oauth_client_preparerequest_signature_key_configuration": {
    "header_en": "Signature Key Configuration",
    "content_en": "<p>Après retour d'authentification, le client se connecte à l'endpoint de jeton pour récupérer le jeton d'identité (et un jeton d'accès). Ce jeton d'identité (ID token) doit être validé avant de considérer l'authentification comme effective. Parmi les différents tests de validation, l'un des plus importants est la vérification de signature.</p><p>Le jeton d'identité est un jeton JSON (JWT) signé par une clé privée de l'IdP (ce qui en fait techniquement un JWS). Pour vérifier la signature, le client doit disposer de la clé publique de l'IdP correspondant à la clé de signature.</p><p>Les clés étant susceptibles de changer dans le temps (leur rotation étant une bonne pratique de sécurité), les IdP les mettent à disposition au travers d'une URL (appelée JWKS URI). Le client de fédération donne toutefois la possibilité de fournir manuellement la bonne clé à des fins de test.</p><ul><li>JWKS URI : URL de récupération automatique des clés publiques, (par exemple https://societe.okta.com/oauth2/v1/keys). Lorsque la configuration des endpoint est réalisée automatiquement, l'URL est récupérée à cette occasion</li><li>Local configuration : la clé publique est fournie directement dans le formulaire</li></ul>"
  },
  "oauth_client_preparerequest_jwks_uri": {
    "header_en": "JWKS URI",
    "content_en": "<p>L'URI JWKS est publiée par l'IdP pour que le client récupère en temps réel la liste des clés publiques à utiliser pour vérifier la signature du jeton d'identité (et celle des jetons d'accès s'ils sont au format Json Web Token). Afin de rendre possible une rotation des clés, l'IdP a la possibilité d'en publier plusieurs. Chaque clé est repérée par un identifiant pour que le client puisse déterminer la clé qui correspond au jeton qu'il a reçu (et qui contient la référence à l'identifiant.</p><p>La spécification n'impose pas de syntaxe à l'URL, qui doit obligatoirement être en https. Voici quelques exemples de userinfo endpoint :</p><ul><li>https://login.microsoftonline.com/b22a2822-5261-4ea7-b000-c17131389b33/discovery/v2.0/keys</li><li>https://societe.okta.com/oauth2/v1/keys</li></ul><p>Ce paramètre est à récupérer auprès de l'IdP. Il est la plupart du temps donné lors de la configuration du client (application), parfois dans une page regroupant tous les endpoint ou toutes les options.</p>"
  },
  "oauth_client_preparerequest_signature_key": {
    "header_en": "Signature Key",
    "content_en": "<p>S'il est préférable que le client récupère en temps réel les clés de vérification du jeton par l'URI JWKS, le client de test de fédération donne la possibilité de lui fournir directement la clé à utiliser</p><p>Une clé ressemble à</p><ul><li>{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"&lt;identifiant de la clé&gt;\",\"use\":\"sig\",\"e\":\"AQAB\",\"n\":\"g53BhV2Rx5CHaa...RNozJLU0t1eNU9qplC3AbkbN3v8weG6ew\"}</li></ul><p>(il s'agit ici d'une clé RSA, mais des clés d'autres types sont permises par la norme)</p>"
  },
  "oauth_client_preparerequest_client_id": {
    "header_en": "Client ID",
    "content_en": "<p>L'IdP attribue un identifiant unique à chaque application qu'il doit authentifier. Cet identifiant est appelé Client ID. C'est ce qui lui permet de savoir quelle politique de sécurité appliquer. Il sert aussi lors des différentes vérifications : authentification lors des appels d'API, validation des jetons, contrôle de l'URL de retour</p><p>Ce paramètre est évidemment à récupérer auprès de l'IdP</p>"
  },
  "oauth_client_preparerequest_client_secret": {
    "header_en": "Client Secret",
    "content_en": "<p>Lorsque le client se connecte aux endpoint de l'IdP (récupération des jetons par exemple), il est formellement authentifié par la donnée du Client ID et par une méthode d'authentification. Le client de test de fédération n'est actuellement compatible qu'avec la méthode client_secret_post, qui est un simple mot de passe.</p><p>Les autres méthodes d'authentification sera prochainement prises en charge :</p><ul><li>client_secret_basic : transmission du mot de passe en en-tête de la requête HTTP</li><li>client_secret_jwt : authentification par JWT signé en HMAC (de fait une authentification par HMAC)</li><li>private_key_jwt : authentification par JWT signé par une clé privée. La clé publique doit être communiquée à l'IdP pour qu'il puisse vérifier la signature</li></ul><p>Les jetons non signés (méthode none) ne sont pas autorisés pour des raisons évidentes de sécurité</p>"
  },
  "oauth_client_preparerequest_scope": {
    "header_en": "Scope",
    "content_en": "<p>Le scope OAuth 2 permet de véhiculer le type d'autorisation demandée au serveur d'autorisation. Une application pourra par exemple demander des droits en écriture sur un objet particulier, et l'exprimera en fournissant des scopes (périmètres) associés.</p><p>En ajoutant le scope offline_access, le client indique à l'IdP qu'il souhaite recevoir un jeton de rafraîchissement du jeton d'accès en même temps que les autres jetons.</p>"
  },
  "oauth_client_preparerequest_response_type": {
    "header_en": "Response Type",
    "content_en": "<p>Le paramètre response type indique la cinématique souhaitée par le client : code d'autorisation, implicite, hybride. Etant donné que la cinématique implicite a été rendue obsolète, le client de test de fédération ne propose que la cinématique code.</p>"
  },
  "oauth_client_preparerequest_introspection_uri": {
    "header_en": "Introspection endpoint",
    "content_en": "<p>Il s'agit d'un URL présent chez l'IdP. Cet endpoint permet à un client de demander à l'IdP si le token en sa posession est valide. Le client délègue la vérification du token au fournisseur d'accès.</p>"
  },
  "oauth_client_preparerequest_response_mode": {
    "header_en": "Response mode",
    "content_en": "<p>Le paramètre response mode permet de préciser de quelle manière le serveur d'autorisation va transmettre les informations de retour au client.</p>"
  },
  "oauth_client_preparerequest_validation_method": {
    "header_en": "Response mode",
    "content_en": "<p>Ce paramètre permet de définir la manière dont le client va vérifier la validité du jeton d'accès obtenu auprès de l'IdP. L'Introspection permet de délégué la vérification à l'IdP lui même en lui envoyant le jeton sur un endpoint précis. L'option signature signifie que le client va lui même vérifier la signature du jeton en récupérant la clé chez l'IdP</p>"
  },
  "oauth_client_preparerequest_state": {
    "header_en": "State",
    "content_en": "<p>Un client de fédération peut communiquer un identifiant de la requête (état ou state) qu'il réalise en même temps que la requête d'authentification est envoyée à l'IdP. Ce dernier se doit alors de fournir de nouveau cette valeur lors de la réponse (lors de l'étape de communication du code). Le client a alors le moyen de vérifier que la réponse en question correspond bien à une demande qu'il a faite. Pour cela il devra évidemment avoir conservé en session l'identifiant qu'il avait généré lors de la requête.</p><p>Il est fortement recommandé de faire cette vérification afin de se prémunir contre les attaques de type CSRF où un attaquant pourrait déclencher à distance une authentification sans que l'utilisateur ne s'en aperçoive, du fait des mécanismes de SSO. Une fois une authentification acquise, l'attaquant enchaîne alors sur une attaque CSRF auprès de l'application ciblée.</p><p>Aduneo Identity Federation Test ne permet pas de modifier cette valeur qui est utilisée en interne pour le suivi des requêtes d'authentification et faire le lien avec les différents clients configurés.</p>"
  },
  "oauth_client_preparerequest_nonce": {
    "header_en": "Nonce",
    "content_en": "<p>Le nonce ajoute une protection de sécurité parallèle à la fourniture d'un state. Il s'agit cette fois de déjouer les attaques de type rejeu.</p><p>Si un attaquant est entré en possession d'un jeton d'identité, il pourrait tenter de le présenter à l'application et usurper l'identité d'un utilisateur légitime. Ce vecteur d'attaque est l'une des raisons pour lesquelles la cinématique <i>implicit</i> a été retirée.</p><p>Mais même avec la cinématique <i>authorization code</i>, une attaque de rejeu est envisageable. On peut imaginer le cas d'un utilisateur qui vient de perdre ses accès et qui tenterait de réutiliser un ancien jeton alors que l'IdP lui refuse son authentification.</p><p>La protection contre le rejeu consiste pour le client à générer un identifiant unique lors de la demande d'authentification, qui est communiquée à l'IdP en même temps que la demande d'authentification. L'IdP intègre cet identifiant (appelé nonce - code à usage unique) dans le jeton d'identité qu'il génère et qu'il communique au client. Ce dernier vérifie alors que le nonce reçu correspond bien à celui qu'il a généré lors de la demande.</p><p>Le client devra évidemment avoir conservé le nonce en session pour le retrouver au retour d'authentification.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "oauth_client_preparerequest_prompt": {
    "header_en": "Prompt (interactions avec l'utilisateur)",
    "content_en": "<p>Le paramètre <i>prompt</i> indique à l'IdP les interactions qu'il souhaite qu'il ait avec l'utilisateur, en termes d'authentification et de consentement.</p><p>Plusieurs cas d'usage sont rendus possibles avec <i>prompt</i> : </p><ul><li>identification sans authentification : un portail personnalisation sa page d'accueil peut souhaiter disposer de l'identité du visiteur si elle est disponible, mais ne pas le forcer à réaliser une authentification dans le cas contraire</li><li>une application souhaite confirmer une authentification avant d réaliser une opération sensible</li><li>un utilisateur disposant de plusieurs comptes dans une application peut souhaiter basculer d'un compte à l'autre</li></ul><p>Avec <i>prompt</i> le client indique à l'IdP s'il doit afficher ou non une page d'authentification ou de sélection de consentement, essentiellement dans le cadre d'un fonctionnement en SSO (réauthentification transparente)<.p><p>Il propose les valeurs suivantes : </p><ul><li>none : l'IdP ne doit pas afficher de page d'authentification, même si le visiteur n'a pas encore été authentifié. Dans ce cas, l'IdP doit retourner une information indiquant que cet état de fait</li>login : l'IdP ne doit pas tenir compte du fait que l'utilisateur a été déjà authentifié et doit l'authentifier de nouveau</li><li>consent : l'IdP doit demander de nouveau à l'utilisateur son consentement à la transmission de ses données personnelles à l'application</li><li>select_account : l'IdP doit demander à l'utilisateur de sélectionner le compte avec lequel il souhaite être authentifié à l'application</li></ul><p>La spécification OIDC indique qu'il est possible de donner plusieurs valeurs de <i>prompt</i>, par exemple choisir un nouveau compte et forcer son authentification. Cette possibilité sera prochainement disponible avec Aduneo Identity Federation Test qui n'autorise pour le moment qu'une seule valeur.</p><p>Ce paramètre fait partie des paramètres optionnels d'une requête d'authentification.</p>"
  },
  "/oidcadmin/name": {
    "header_en": "Nom du client",
    "content_en": "Nom du client dans ClientFedID\n\nNe joue aucun rôle dans la cinématique *OpenID Connect*",
    "format_en": "lmd"
  },
  "/oidcadmin/endpoint_configuration": {
    "header_en": "Méthode de configuration des points d'entrée de l'OP",
    "content_en": "Les points d'entrée de l'*OpenID Provider* correspondent aux URL accédés par le client pour récupérer les jetons, informations, clés publiques, etc.\n\nClientFedID propose deux méthodes pour les donner :\n- *Discovery URI* : au travers d'un document de configuration\n- *Local configuration* : par saisie de chaque URL individuellement",
    "format_en": "lmd"
  }
}